<link rel="import" href="bower_components/polymer/polymer-element.html">
<script src="getElementAt.js"></script>
<script src="node_modules/video.js/dist/video.js"></script>
<script src="node_modules/hammerjs/hammer.min.js"></script>
<script src="node_modules/svgjs/dist/svg.min.js"></script>
<script src="lib/videojs-touch.js"></script>

<dom-module id="camomile-touch-player">

  <template>
  <style>
    html,body{
      overflow-y: hidden;
    }
     #interactivePlayer { position:relative; width:100%;}
     #video { top: 0; left: 0; width:640; height:480; z-index:1 }
     #drawing{top:0;left:0;width: 640;height:480;z-index: 2}
     #interaction {top: 0; left: 0; width:640; height:480; z-index:3 }
  </style>
  <video id="video"
  width="640" height="480" poster='lib/poster.gif'>
  <source src="{{medium_url}}" type="video/{{format}}">
  </video>
  <div id='drawing'></>
    <script type="text/javascript">

    var lastMove=null;
    var i=0;
    var start=[0,0,0];


    var _wrap = function() {

      var videoElement = this.el();
      var parent = videoElement.parentNode;

      var draw=SVG('drawing').size(this.videoWidth(),this.videoHeight());
      var circle=draw.circle(this.videoHeight()/20).fill({color:'#f06',opacity:0});
      var arrow=draw.line(0,0,100,100).stroke({color:'#f06',opacity:0,width:10});
      var wrapper = document.createElement('div');
      wrapper.id = 'interactivePlayer';
      // see "how to maintain the aspect ratio of a div using only CSS
      // http://stackoverflow.com/questions/1495407/how-to-maintain-the-aspect-ratio-of-a-div-using-only-css
      var videoHeight = this.videoHeight();
      var videoWidth = this.videoWidth();

      // Work in progress
      // var arrowHead = draw.marker(2,2,function(add) {
      //   var rectangle=add.rect(videoHeight/25,videoHeight/25).fill({color:'#f06',opacity:0});
      // });
      //
      // arrow.marker('end',arrowHead)

      wrapper.style.paddingBottom = 100 * videoHeight / videoWidth + "%";

      parent.replaceChild(wrapper, videoElement);
      wrapper.appendChild(videoElement);


      // add touch overlay on top of player
      var touchLayer = document.createElement('div');
      touchLayer.id = 'interaction';
      wrapper.appendChild(touchLayer);

      // add Hammer to touch overlay
      var hammer = new Hammer.Manager(touchLayer);
      // Tap recognizer with minimal 2 taps
      hammer.add( new Hammer.Tap({ event: 'doubletap', taps: 2, interval:500, posThreshold:50 }) );
      // Single tap recognizer
      hammer.add( new Hammer.Tap({ event: 'singletap' }) );
      // Pan recognizer
      hammer.add(new Hammer.Pan({event:'pan', threshold:1}));
      // Pinch recognizer
      hammer.add(new Hammer.Pinch({event:'pinch'}))

      // we want to recognize this simulatenous, so a doubletap will be detected even while a tap has been recognized.
      hammer.get('doubletap').recognizeWith('singletap');
      // we only want to trigger a tap, when we don't have detected a doubletap
      hammer.get('singletap').requireFailure('doubletap');
      // we only want to pinch if taps fail
      hammer.get('pan').requireFailure('pinch')

      hammer.on('singletap', function(event) {
        height = touchLayer.clientHeight;
        width = touchLayer.clientWidth;
        circle.center(event.center.x,event.center.y);
        circle.animate(500).fill({opacity:0.8}).animate(500).fill({opacity:0});
        console.log({'type': event.type,
        'x': event.center.x/width,
        'y': event.center.y/height,
        'currentTime': player.currentTime()});
      });

      hammer.on('doubletap', function() {
        if (player.paused()) {
          player.play()
        } else {
          player.pause()
        }
      });

      hammer.on('pinchout', function(event) {
        if (i==8&&player.playbackRate<1.9) {
          i=0;
          player.playbackRate+=0.2;
          console.log(player.playbackRate)
          console.log({'type': event.type,
          'currentTime': player.currentTime(),'i':i});
        } else if(player.playbackRate<1.9){
          i++;
        }

      });

      hammer.on('pinchin', function(event) {
        if (i==8&&player.playbackRate>0.41) {
          i=0;
          player.playbackRate-=0.2;
          console.log(player.playbackRate)
          console.log({'type': event.type,
          'currentTime': player.currentTime(),'i':i});
        } else if(player.playbackRate>0.41){
          i++;
        }
      });

      hammer.on('panstart', function(event) {
        height = touchLayer.clientHeight;
        width = touchLayer.clientWidth;
        start=[event.center.x,event.center.y,player.currentTime()]
        console.log({'type': event.type,
        'x': event.center.x/width,
        'y': event.center.y/height,
        'currentTime': player.currentTime()});
      });
      hammer.on('panend', function(event) {
        height = touchLayer.clientHeight;
        width = touchLayer.clientWidth;
        console.log({'type': event.type,
        'x': event.center.x/width,
        'y': event.center.y/height,
        'currentTime': player.currentTime(),'delta':player.currentTime()-start[2]<3});
        if (player.currentTime()-start[2]<2) {
          arrow.animate(500).stroke({opacity:0.8}).plot(start[0],start[1],event.center.x,event.center.y).animate(1000).stroke({opacity:0});
        }
      });
            player.play();
    };
    var player = document.getElementById('player1').$.video;
    player.on('loadedmetadata', _wrap);
    player.on('canplay',function(){
      console.log('canplay')
    });

    // var touchPlayer = TouchPlayer('player', options...)
    document.ontouchmove = function(event){
      event.preventDefault();
    }
    </script>
  </template>

  <script>
    class CamomilePlayer extends Polymer.Element {
      static get is() {
        return "camomile-touch-player";
      }

      constructor() {
        super();
      }

      _setupMediumView(mediumView) {
        console.log("setting player",this.id,"to",mediumView.medium_url);
        this.medium_url = mediumView.medium_url;
        this.format = mediumView.format;
        this.$.video.load();
        // try {
        //   this.player.dispose();
        // } catch (e) {
        //   console.log(e);
        // }
        // if (typeof this.player=='undefined'){
        //   this.player=videojs(this.$.video);
        //   this.player.touch({'singletap':function(event){console.log({'touchÃ©':this})},'doubletap':function(){if (this.paused()){this.play()}else{this.pause()}}});
        //   console.log('new');
        // }
        // console.log(this);
        // this.player.src({src:mediumView.medium_url,type:('video/web',this.format)});
        // this.player.load();
      }


      _resetMediumView() {
        console.log("reset player",this.id);
        this.medium_url="";
        this.format="";
        this.$.video.load();
      }

      ready() {

        super.ready();
        let syncCurrentTime;
        let syncAll;
        let syncPlaying;
        this.video=this.$.video;


        if(this.syncAll) {
          syncAll = getElementAt(this.syncAll);

          if(syncAll.medium) {
            this._setupMediumView(syncAll);
          }

          syncAll.addEventListener("ready", () => this._setupMediumView(syncAll));
          syncAll.addEventListener("reset", () => this._resetMediumView());
          syncCurrentTime=syncAll;
          syncPlaying=syncAll;
        }

        if(this.syncCurrentTime) {
          syncCurrentTime = getElementAt(this.syncCurrentTime);

          if(syncCurrentTime.medium) {
            this._setupMediumView(syncCurrentTime)
          }
          syncCurrentTime.addEventListener("ready", () => this._setupMediumView(syncCurrentTime));
          syncCurrentTime.addEventListener("reset", () => this._resetMediumView());
        }

        if(this.syncPlaying) {
          syncPlaying = getElementAt(this.syncPlaying);

          if(syncPlaying.medium) {
            this._setupMediumView(syncPlaying)
          }
          syncPlaying.addEventListener("ready", () => this._setupMediumView(syncPlaying));
          syncPlaying.addEventListener("reset", () => this._resetMediumView());
        }

        if(syncCurrentTime) {
          this.video.addEventListener("timeupdate",() => {
            syncCurrentTime.publish(this.id,"currentTime",this.video.currentTime);
          });
          syncCurrentTime.subscribe(this.id,"currentTime",() => {
            this.video.currentTime=syncCurrentTime.currentTime;
          });
        }


        if(syncPlaying) {
          this.video.addEventListener("play", () => {
            syncPlaying.publish(this.id,"playing",true);
          });
          this.video.addEventListener("pause", () => {
            syncPlaying.publish(this.id,"playing",false);
          });
        }
      }


      static get properties() {
        return {
          syncCurrentTime: String,
          syncPlaying: String,
          syncAll: String,
          id: String
        }
      }
    }
    customElements.define(CamomilePlayer.is, CamomilePlayer);
  </script>

</dom-module>
