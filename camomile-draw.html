<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="bower_components/polymer/lib/elements/dom-if.html">
<script src="getElementAt.js"></script>
<link rel="import" href="materialize.html">
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="./node_modules/materialize-css/dist/js/materialize.min.js"></script>
<script src="node_modules/svgjs/dist/svg.min.js"></script>


<dom-module id="camomile-draw">
  <template>
    <style include='materialize'>

    </style>
    <div id="videoControls" style='position:relative;top:25px'>
    <button type="button" id="play-pause">Play/Pause</button>
    <input type="range" id="seek-bar" value="0">
  </div>
  </template>

  <script>
  class CamomileDraw extends Polymer.Element {
    static get is() {
      return "camomile-draw";
    }

    constructor() {
      super();
    }

    _setupLayer(camomileLayerState){
      this.layerState=camomileLayerState;
      if (this.player) {
        if (this.player.wrapped){
          this.setFunctions();
          this.player.wrapped=false;}
        }
      }

      _setupPlayer(camomilePlayer){
        this.player=camomilePlayer;
        if(this.layerState){
          if(this.layerState.populated&&this.player.wrapped){
            this.setFunctions();
            this.player.wrapped=false;
          }
        }
      }

      _resetLayer(){
        this.layerState='';
      }

      ready() {
        super.ready();
        const camomilePlayer=getElementAt(this.srcPlayer);
        const camomileLayerState=getElementAt(this.srcLayerstate);
        this.colors=['#f06','#ff6600','#ff33cc','#9966ff','#0066ff','#00ccff','#00cc00','#996633','#ffff00','#ffffff'];

        if (camomileLayerState.populated){
          this._setupLayer(camomileLayerState);
        }
        if (camomilePlayer.wrapped){
          this._setupPlayer(camomilePlayer);
        }
        camomileLayerState.addEventListener('populate_annotations',()=> this._setupLayer(camomileLayerState));
        camomileLayerState.addEventListener('reset',()=>this._resetLayer())
        camomilePlayer.addEventListener('wrapped',()=> this._setupPlayer(camomilePlayer))
      }

      _popAnnos(data){
        this.previousTime = 0;
        var rect = this.rect[0];
        var delay = 0;
        const draw = this
        const videoElement = this.player.video;
        var i = 1;

        this.annotations=JSON.parse(JSON.stringify(data));
        var annotations=this.annotations;
        for (let i=0;i<annotations.length;i++){
          annotations[i].data=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].data))
          annotations[i].fragment=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].fragment))
          annotations[i].toBeResolved=true;
        }
        this.annotations.sort((a,b)=>a.data.track_id-b.data.track_id);
        function first(rect){
          setTimeout(function() {
            var rect = draw.rect[0]
            rect = rect.stroke({width:3})
            for (let j=0; j<draw.annotations[0].data.coord.length;j++){
              rect = rect.plot([draw.annotations[0].data.coord[j][0]*videoElement.clientWidth,draw.annotations[0].data.coord[j][1]*videoElement.clientHeight],[
                draw.annotations[0].data.coord[j][0]*videoElement.clientWidth,draw.annotations[0].data.coord[j][3]*videoElement.clientHeight],
                [draw.annotations[0].data.coord[j][2]*videoElement.clientWidth,draw.annotations[0].data.coord[j][3]*videoElement.clientHeight],
                [draw.annotations[0].data.coord[j][2]*videoElement.clientWidth,draw.annotations[0].data.coord[j][1]*videoElement.clientHeight])
                .move(draw.annotations[0].data.coord[j][0]*videoElement.clientWidth,draw.annotations[0].data.coord[j][1]*videoElement.clientHeight).delay(30)
              }
              rect = rect.stroke({width:0})
            },Math.round(draw.annotations[0].fragment.startTime*1000))
            return null
          }
          videoElement.addEventListener('play',() => {
            first();
            this.removeEventListener('play',first())
          })
          videoElement.addEventListener('timeupdate',() => {
            var value = (100/videoElement.duration)*videoElement.currentTime;
            draw.$.videoControls.children[1].value=value;
            if((this.previousTime-this.player.video.currentTime)>0){
              for (let j = 0; j<=i;j++){
                if(this.annotations[i-j].fragment.startTime>this.player.video.currentTime){
                  this.annotations[i-j].toBeResolved=true;
                }
                else{
                  i=i-j+1;
                  for (let j=0;j<draw.rect.length;j++){
                    draw.rect[j].stop();
                    draw.rect[j].stroke({width:0})
                  }
                  console.log('Went back to ',i,' with startTime', this.annotations[i-j].fragment.startTime,' currentTime is', this.player.video.currentTime)
                  break;
                }
              }
            }
            if((this.previousTime-this.player.video.currentTime)<-1){
                for (let j = 0; j<=(this.annotations.length-i);j++){
                  if(this.annotations[i+j].fragment.startTime<this.player.video.currentTime){
                    this.annotations[i+j].toBeResolved=false;
                  }
                  else{
                    i=i+j+1;
                    for (let j=0;j<draw.rect.length;j++){
                      draw.rect[j].stop();
                      draw.rect[j].stroke({width:0})
                    }
                    console.log('Went up to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
                    break;
                  }
                }
              }
              delay = this.annotations[i].fragment.startTime - this.player.video.currentTime;
            if ((delay)<0.5 && (delay)>-0.5 && this.annotations[i].toBeResolved && !(this.player.video.paused)){
              this.annotations[i].toBeResolved = false;
              if (this.annotations[i-1].fragment.durationTime[1]>=this.annotations[i].fragment.startTime && !(this.annotations[i-1].fragment.startTime==this.annotations[i].fragment.startTime)){
                this._updateSVG(i);
              }
              else if (this.annotations[i-1].fragment.durationTime[1]<this.annotations[i].fragment.startTime){
                this._updateSVG(i);
              }
              else if ( (this.annotations[i-1].fragment.startTime==this.annotations[i].fragment.startTime) && !(this.annotations[i-1].data.coord[0][0]==this.annotations[i].data.coord[0][0])) {
                this._updateSVG(i);
              }
              i++;
            }
            this.previousTime=this.player.video.currentTime;
          })
        }

        _updateSVG(i,bool){
          // Automatic creation of rectangle if multiple faces
          const videoElement = this.player.video;
          const drawingBoard = this.player.draw;
          var draw = this;
          var u = 0;
          for (let i = 0; i<this.rect.length; i++){
            if (!(this.rect[i].fx.active)){
              u=i;
              break;
            }
            if (u==0 && i == (this.rect.length-1)){
              console.log('new rectangle creation');
              u = this.rect.length;
              this.rect.push(drawingBoard.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({color:draw.colors[u%10]}));
              this.rect[u].delay();
              console.log(this.rect);
            }
          }
          console.log('update',u);

          const wait = Math.round((draw.annotations[i].fragment.startTime-draw.player.video.currentTime)*1000)
          var rect = this.rect[u];
          setTimeout(function() {
            if (Math.pow(draw.annotations[i].fragment.startTime-draw.player.video.currentTime,2)<1){
            rect = rect.stroke({width:3});
            for (let j=0; j<draw.annotations[i].data.coord.length;j++){
              rect = rect.plot([draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight],[
                draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
                [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
                [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight])
                .move(draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight)
                if(!(j%5==0)){
                  rect=rect.delay(40)
                }
              }
              rect = rect.stroke({width:0});
            }
            else {
              console.log('changement de temps ?');
            }
            },wait)
          }



          setFunctions(){
            const draw = this.player.draw;
            const videoElement = this.player.video;
            const drawingBoard = this;
            this.rect=[];
            this.rect[0] = draw.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({width:0, color:drawingBoard.colors[0]});
            this.rect[0].delay();
            var rect = this.rect;
            const layerState = this.layerState;

            this._popAnnos(layerState.annotations)

            layerState.addEventListener("populate_annotations",({detail:{data}}) => {
              this._popAnnos(data)
            });

            layerState.addEventListener("reset_annotations",() => {
              this.annotations=null;
            });

            layerState.addEventListener("add_annotation",({detail:{data}}) => {
              this.push("annotations",data);
              this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
            });
            layerState.addEventListener("update_annotation",({detail:{data}}) => {
              const annotationIndex=this.annotations.findIndex(annotation => annotation._id===data._id);
              this.splice("annotations", annotationIndex, 1,data);
              this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
            });
            layerState.addEventListener("delete_annotation",({detail:{id}}) => {
              const annotationIndex=this.annotations.findIndex(annotation => annotation._id===id);
              this.splice("annotations", annotationIndex, 1);
            });

            this.$.videoControls.children[1].addEventListener('change',function(){
              var time = videoElement.duration * this.value/100;
              videoElement.currentTime=time;
            })
            this.$.videoControls.children[0].addEventListener('click',function(){
              if (videoElement.paused) {
                videoElement.play();
                for (let i = 0; i<rect.length;i++){
                  rect[i].play();
                }
              }else {
                videoElement.pause();
                for (let i = 0; i<rect.length;i++){
                  rect[i].pause();
                }
              }})
            this.player.on('doubletap',function(){
              if (videoElement.paused) {
                videoElement.play();
                for (let i = 0; i<rect.length;i++){
                  rect[i].play();
                }
              }else {
                videoElement.pause();
                for (let i = 0; i<rect.length;i++){
                  rect[i].pause();
                }
              }})

            }



            static get properties() {
              return {
                srcLogin: String,
                srcPlayer: String,
                srcLayerstate:String,
                id: String
              };
            }
          }
          customElements.define(CamomileDraw.is, CamomileDraw);
          </script>

        </dom-module>
