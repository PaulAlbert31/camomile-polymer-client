<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="bower_components/polymer/lib/elements/dom-if.html">
<script src="getElementAt.js"></script>
<link rel="import" href="materialize.html">
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="./node_modules/materialize-css/dist/js/materialize.min.js"></script>
<script src="node_modules/svgjs/dist/svg.min.js"></script>


<dom-module id="camomile-draw">
  <template>
  <style include='materialize'>
  </style>
  <a class="btn-floating btn-large waves-effect waves-light red" style='display:inline-block;top:-5%' id='addButton'><i class="material-icons">add</i></a>
  <div id='container' class = 'row' style='display:inline-block;overflow:scroll;width:100%;height:100%'><div id='miniatures' class='col s12' style='display:inline-block;width:auto;height:100px'></div></div>
  <a class="btn waves-effect waves-light red" style='display:inline-block;top:-5%' id='pushButton'><i class="material-icons">backup</i>Push your identification</a>

</template>

<script>
class CamomileDraw extends Polymer.Element {
  static get is() {
    return "camomile-draw";
  }

  constructor() {
    super();
  }

  _setupLayer(camomileLayerState){
    this.layerState=camomileLayerState;
    if (this.player) {
      if (this.player.wrapped){
        this.setFunctions();
        this.player.wrapped=false;}
      }
    }

    _setupPlayer(camomilePlayer){
      this.player=camomilePlayer;
      this.player.$.videoControls.children[0].style.width='100%';
      const videoElement = this.player.video;
      this.faceAnnotations={};
      this.player.draw.size(videoElement.clientWidth,videoElement.clientHeight)
      if(this.layerState){
        if(this.layerState.populated&&this.player.wrapped){
          this.setFunctions();
          this.player.wrapped=false;
        }
      }
    }

    _resetLayer(){
      this.layerState='';
    }

    ready() {
      super.ready();
      const camomilePlayer=getElementAt(this.srcPlayer);
      const camomileLayerState=getElementAt(this.srcLayerstate);
      this.colors=['#f06','#ff6600','#ff33cc','#9966ff','#0066ff','#00ccff','#00cc00','#996633','#ffff00','#ffffff'];

      if (camomileLayerState.populated){
        this._setupLayer(camomileLayerState);
      }
      if (camomilePlayer.wrapped){
        this._setupPlayer(camomilePlayer);
      }
      camomileLayerState.addEventListener('populate_annotations',()=> this._setupLayer(camomileLayerState));
      camomileLayerState.addEventListener('reset',()=>this._resetLayer())
      camomilePlayer.addEventListener('wrapped',()=> this._setupPlayer(camomilePlayer))
    }

    _popAnnos(data){
      this.previousTime = 0;
      var rect = this.rect[0];
      var delay = 0;
      const draw = this
      const videoElement = this.player.video;
      var i = 0;

      this.annotations=JSON.parse(JSON.stringify(data));
      var annotations=this.annotations;
      for (let i=0;i<annotations.length;i++){
        annotations[i].data=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].data))
        annotations[i].fragment=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].fragment))
        annotations[i].toBeResolved=true;
      }
      this.annotations.sort((a,b)=>a.data.track_id-b.data.track_id);
      videoElement.addEventListener('timeupdate',() => {
        if((this.previousTime-this.player.video.currentTime)>0){
          for (let j = 0; j<=i;j++){
            if(this.annotations[i-j].fragment.startTime>this.player.video.currentTime+0.5){
              this.annotations[i-j].toBeResolved=true;
            }
            else{
              i=i-j+1;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop(true,true);
                draw.rect[j].stroke({width:0})
              }
              console.log('Went back to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
            if(i==j){
              i=i-j;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop(true,true);
                draw.rect[j].stroke({width:0})
              }
              console.log('Went back to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
          }
        }
        if((this.previousTime-this.player.video.currentTime)<-1){
          for (let j = 0; j<=(this.annotations.length-i);j++){
            if(this.annotations[i+j].fragment.startTime<this.player.video.currentTime){
              this.annotations[i+j].toBeResolved=false;
            }
            else{
              i=i+j;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop(true,true);
                draw.rect[j].stroke({width:0})
              }
              console.log('Went up to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
          }
        }
        delay = this.annotations[i].fragment.startTime - this.player.video.currentTime;
        if ((delay)<0.5 && (delay)>-0.5 && this.annotations[i].toBeResolved && !(this.player.video.paused)){
          this.annotations[i].toBeResolved = false;
          this._updateSVG(i);
          i++;
        }
        this.previousTime=this.player.video.currentTime;
      })
    }
    updateMetadata(){
      if (!this.faceAnnotations=={}){
        this.layerState.client.setLayerMetadata(this.layerState.layer,{'name':'face_metadata','level1':{'metadata_array':this.faceAnnotations}}).then(result=>{console.log(result);

        })
      }
      this.layerState.client.getLayerMetadata(this.layerState.layer,'level1').then(result=>{console.log(result);})

    }

    _updateSVG(i){
      // Automatic creation of rectangle if multiple faces
      const videoElement = this.player.video;
      const drawingBoard = this.player.draw;
      var draw = this;
      var u = 0;
      for (let i = 0; i<this.rect.length; i++){
        if (!(this.rect[i].fx.active)){
          u=i;
          break;
        }
        if (u==0 && i == (this.rect.length-1)){
          console.log('new rectangle creation');
          u = this.rect.length;
          this.rect.push(drawingBoard.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({color:draw.colors[u%10]}));
          this.rect[u].delay();
          console.log('Nombre de rectangles : ',this.rect.length);
        }
      }

      const wait = Math.round((draw.annotations[i].fragment.startTime-draw.player.video.currentTime)*1000)
      var rect = this.rect[u];

      setTimeout(function() {
        if (Math.pow(draw.annotations[i].fragment.startTime-draw.player.video.currentTime,2)<0.8){
          rect = rect.stroke({width:3});
          rect.id(i);
          for (let j=0; j<draw.annotations[i].data.coord.length;j++){
            if (draw.annotations[i].fragment.durationTime[1]-draw.player.video.currentTime<-0.5){
              rect.stroke({width:0})
              console.log('breaking');
              break;
            }
            rect = rect.plot([draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight],[
              draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
              [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
              [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight])
              .move(draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight)
              if(!(j%5==0)){
                rect=rect.delay(40)
              }
            }
            rect = rect.stroke({width:0});
          }
        },wait)

      }
      pushButton(){
        this.player.video.pause();
        for (let j = 0; j<this.rect.length;j++){
          if(this.rect[j].fx.active){
            this.rect[j].pause()
          }
        }
        this.updateMetadata();
      }

      addButton(){
        this.player.video.pause();
        for (let j = 0; j<this.rect.length;j++){
          if(this.rect[j].fx.active){
            this._getMin(this.rect[j])
            this.rect[j].pause()
          }
        }
      }
      _getMin(rect){
        const draw = this;
        const videoElement = this.player.video;
        const ratioHeight = videoElement.videoHeight/videoElement.clientHeight;
        const ratioWidth = videoElement.videoWidth/videoElement.clientWidth;
        const miniatures = this.$.miniatures;
        const sourceX=Math.round(rect.x()*ratioWidth);
        const sourceY=Math.round(rect.y()*ratioHeight);
        const sourceWidth = Math.round(rect.width()*ratioWidth);
        const sourceHeight = Math.round(rect.height()*ratioHeight);
        var specialDiv = document.createElement('div');
        specialDiv.style.cssText = 'display:inline-block';
        var form = document.createElement('form');
        form.style.cssText='width:70px'
        var canvas1 = document.createElement('canvas');
        canvas1.height = 50
        canvas1.width = 1.4 * canvas1.height;
        specialDiv.style.cssText = 'display:inline-block;';
        var inputField = document.createElement('input');
        // var inputLabel = document.createElement('i');
        // inputLabel.className = 'material-icons prefix';
        // inputLabel.innerHTML = 'account_circle';
        // inputLabel.style.cssText = 'display:inline-block;width:20px'
        inputField.placeholder = 'Name';
        inputField.style.cssText = 'position:relative;display:inline-block;width:70px';
        inputField.type = 'text';
        var inputSubmit = document.createElement('input');
        inputSubmit.style.cssText='position:absolute;left:-9999px'
        inputSubmit.type = 'submit';
        miniatures.appendChild(specialDiv);
        specialDiv.appendChild(canvas1);
        specialDiv.appendChild(form);
        form.appendChild(inputField);
        form.appendChild(inputSubmit);
        form.onsubmit = function(e){
          e.preventDefault();
          var label = document.createElement('a');
          label.innerHTML = inputField.value;
          label.className = 'truncate center black-text';
          //Canvas capture failed : if the input is empty on submit, the div is deleted
          if(inputField.value == ''){
            this.parentNode.parentNode.removeChild(this.parentNode);
            rect.stop(true,true);
            rect.stroke({width:0});
          }else{
            if (draw.faceAnnotations[inputField.value] === undefined){
              draw.faceAnnotations[inputField.value] = [rect.id()];
            }else{
              draw.faceAnnotations[inputField.value] = draw.faceAnnotations[inputField.value].concat([rect.id()]);
            }
            for (let j=0;j<miniatures.children.length;j++){
              //Should not replace itself
              if (miniatures.children[j].children[1] === this && miniatures.children.length>j+1){
                continue;
              }
              //Replacing existing picture if labels match. Stops as soon as one is found
              if (miniatures.children[j].children[1].children[0].innerHTML == inputField.value){
                miniatures.children[j].replaceChild(specialDiv.children[0],miniatures.children[j].children[0]);
                this.parentNode.parentNode.removeChild(this.parentNode);
                break;
              }
              //No match was found, a new character is created
              if (j==miniatures.children.length-1){
                this.replaceChild(label,inputField)
              }
            }
          }
        }
        var canvastx1 = canvas1.getContext('2d');
        canvastx1.drawImage(videoElement,sourceX,sourceY,sourceWidth,sourceHeight,0,0,canvas1.width*0.95,canvas1.height*0.95);
      }



      setFunctions(){
        const draw = this.player.draw;
        const videoElement = this.player.video;
        const drawingBoard = this;
        this.rect=[];
        this.rect[0] = draw.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({width:0, color:drawingBoard.colors[0]});
        this.rect[0].delay();
        var rect = this.rect;
        const layerState = this.layerState;

        this.$.addButton.addEventListener('click',()=>{this.addButton(this.rect[0])});
        this.$.pushButton.addEventListener('click',()=>{this.pushButton()});

        this._popAnnos(layerState.annotations)

        layerState.addEventListener("populate_annotations",({detail:{data}}) => {
          this._popAnnos(data)
        });

        layerState.addEventListener("reset_annotations",() => {
          this.annotations=null;
        });

        layerState.addEventListener("add_annotation",({detail:{data}}) => {
          this.push("annotations",data);
          this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
        });
        layerState.addEventListener("update_annotation",({detail:{data}}) => {
          const annotationIndex=this.annotations.findIndex(annotation => annotation._id===data._id);
          this.splice("annotations", annotationIndex, 1,data);
          this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
        });
        layerState.addEventListener("delete_annotation",({detail:{id}}) => {
          const annotationIndex=this.annotations.findIndex(annotation => annotation._id===id);
          this.splice("annotations", annotationIndex, 1);
        });


        this.player.on('doubletap',()=>{
          if (videoElement.paused) {
            videoElement.play();
            for (let i = 0; i<rect.length;i++){
              if(rect[i].fx.active){
              rect[i].play();
            }
            }
          }else {
            videoElement.pause();
            this.player.draw.size(videoElement.clientWidth,videoElement.clientHeight)
            for (let i = 0; i<rect.length;i++){
              if(rect[i].fx.active){
              rect[i].pause();
            }
          }
          }})

        }



        static get properties() {
          return {
            srcLogin: String,
            srcPlayer: String,
            srcLayerstate:String,
            id: String
          };
        }
      }
      customElements.define(CamomileDraw.is, CamomileDraw);
      </script>

    </dom-module>
