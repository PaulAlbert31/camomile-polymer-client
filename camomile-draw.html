<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="bower_components/polymer/lib/elements/dom-if.html">
<script src="getElementAt.js"></script>
<link rel="import" href="materialize.html">
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="./node_modules/materialize-css/dist/js/materialize.min.js"></script>
<script src="node_modules/svgjs/dist/svg.min.js"></script>


<dom-module id="camomile-draw">
  <template>
  <style include='materialize'>
  </style>
  <a class="btn-floating btn-large waves-effect waves-light red" style='display:inline-block;top:-5%' id='addButton'><i class="material-icons">add</i></a>
  <div id='miniatures' style='display:inline-block'></div>
</template>

<script>
class CamomileDraw extends Polymer.Element {
  static get is() {
    return "camomile-draw";
  }

  constructor() {
    super();
  }

  _setupLayer(camomileLayerState){
    this.layerState=camomileLayerState;
    if (this.player) {
      if (this.player.wrapped){
        this.setFunctions();
        this.player.wrapped=false;}
      }
    }

    _setupPlayer(camomilePlayer){
      this.player=camomilePlayer;
      this.player.wrapper.style.height='90%';
      this.player.wrapper.firstChild.style.height='90%';
      this.player.wrapper.lastChild.style.height='90%';
      this.player.$.videoControls.style.width='90%';
      this.player.$.videoControls.style.top='-20px';
      this.player.$.videoControls.style.display='inline-block';
      if(this.layerState){
        if(this.layerState.populated&&this.player.wrapped){
          this.setFunctions();
          this.player.wrapped=false;
        }
      }
    }

    _resetLayer(){
      this.layerState='';
    }

    ready() {
      super.ready();
      const camomilePlayer=getElementAt(this.srcPlayer);
      const camomileLayerState=getElementAt(this.srcLayerstate);
      this.colors=['#f06','#ff6600','#ff33cc','#9966ff','#0066ff','#00ccff','#00cc00','#996633','#ffff00','#ffffff'];

      if (camomileLayerState.populated){
        this._setupLayer(camomileLayerState);
      }
      if (camomilePlayer.wrapped){
        this._setupPlayer(camomilePlayer);
      }
      camomileLayerState.addEventListener('populate_annotations',()=> this._setupLayer(camomileLayerState));
      camomileLayerState.addEventListener('reset',()=>this._resetLayer())
      camomilePlayer.addEventListener('wrapped',()=> this._setupPlayer(camomilePlayer))
    }

    _popAnnos(data){
      this.previousTime = 0;
      var rect = this.rect[0];
      var delay = 0;
      const draw = this
      const videoElement = this.player.video;
      var i = 0;

      this.annotations=JSON.parse(JSON.stringify(data));
      var annotations=this.annotations;
      for (let i=0;i<annotations.length;i++){
        annotations[i].data=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].data))
        annotations[i].fragment=JSON.parse(LZString.decompressFromEncodedURIComponent(annotations[i].fragment))
        annotations[i].toBeResolved=true;
      }
      this.annotations.sort((a,b)=>a.data.track_id-b.data.track_id);
      videoElement.addEventListener('timeupdate',() => {
        if((this.previousTime-this.player.video.currentTime)>0){
          for (let j = 0; j<=i;j++){
            if(this.annotations[i-j].fragment.startTime>this.player.video.currentTime){
              this.annotations[i-j].toBeResolved=true;
            }
            else{
              i=i-j;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop();
                draw.rect[j].stroke({width:0})
              }
              console.log('Went back to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
            if(i==j){
              i=i-j;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop();
                draw.rect[j].stroke({width:0})
              }
              console.log('Went back to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
          }
        }
        if((this.previousTime-this.player.video.currentTime)<-1){
          for (let j = 0; j<=(this.annotations.length-i);j++){
            if(this.annotations[i+j].fragment.startTime<this.player.video.currentTime){
              this.annotations[i+j].toBeResolved=false;
            }
            else{
              i=i+j;
              for (let j=0;j<draw.rect.length;j++){
                draw.rect[j].stop();
                draw.rect[j].stroke({width:0})
              }
              console.log('Went up to ',i,' with startTime', this.annotations[i].fragment.startTime,' currentTime is', this.player.video.currentTime)
              break;
            }
          }
        }
        delay = this.annotations[i].fragment.startTime - this.player.video.currentTime;
        if ((delay)<0.5 && (delay)>-0.5 && this.annotations[i].toBeResolved && !(this.player.video.paused)){
          this.annotations[i].toBeResolved = false;
          this._updateSVG(i);
          i++;
        }
        this.previousTime=this.player.video.currentTime;
      })
    }

    _updateSVG(i){
      // Automatic creation of rectangle if multiple faces
      const videoElement = this.player.video;
      const drawingBoard = this.player.draw;
      var draw = this;
      var u = 0;
      for (let i = 0; i<this.rect.length; i++){
        if (!(this.rect[i].fx.active)){
          u=i;
          break;
        }
        if (u==0 && i == (this.rect.length-1)){
          console.log('new rectangle creation');
          u = this.rect.length;
          this.rect.push(drawingBoard.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({color:draw.colors[u%10]}));
          this.rect[u].delay();
          console.log('Nombre de rectangles : ',this.rect.length);
        }
      }

      const wait = Math.round((draw.annotations[i].fragment.startTime-draw.player.video.currentTime)*1000)
      var rect = this.rect[u];
      setTimeout(function() {
        if (Math.pow(draw.annotations[i].fragment.startTime-draw.player.video.currentTime,2)<1){
          rect = rect.stroke({width:3});
          for (let j=0; j<draw.annotations[i].data.coord.length;j++){
            rect = rect.plot([draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight],[
              draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
              [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][3]*videoElement.clientHeight],
              [draw.annotations[i].data.coord[j][2]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight])
              .move(draw.annotations[i].data.coord[j][0]*videoElement.clientWidth,draw.annotations[i].data.coord[j][1]*videoElement.clientHeight)
              if(!(j%5==0)){
                rect=rect.delay(40)
              }
            }
            rect = rect.stroke({width:0});
          }
        },wait)
      }

      addButton(){
        this.player.video.pause();
        for (let j = 0; j<this.rect.length;j++){
          if(this.rect[j].fx.active){
            this._getMin(this.rect[j])
          }
          this.rect[j].pause()
        }
      }
      _getMin(rect){
        const videoElement = this.player.video;
        const ratioHeight = videoElement.videoHeight/videoElement.clientHeight;
        const ratioWidth = videoElement.videoWidth/videoElement.clientWidth;
        const miniatures = this.$.miniatures;
        const sourceX=Math.round(rect.x()*ratioWidth);
        const sourceY=Math.round(rect.y()*ratioHeight);
        const sourceWidth = Math.round(rect.width()*ratioWidth);
        const sourceHeight = Math.round(rect.height()*ratioHeight);
        var specialDiv = document.createElement('div');
        specialDiv.style.cssText = 'display:inline-block;position:relative;left:1px';
        var form = document.createElement('form');
        var canvas1 = document.createElement('canvas');
        var inputField = document.createElement('input');
        var inputSubmit = document.createElement('input');
        inputSubmit.style.cssText='position:absolute;left:-9999px'
        inputSubmit.type = 'submit';
        miniatures.appendChild(specialDiv);
        specialDiv.appendChild(canvas1);
        specialDiv.appendChild(form);
        form.appendChild(inputField);
        form.appendChild(inputSubmit);
        form.onsubmit = function(e){
          e.preventDefault();
          console.log('submit');
          var label = document.createElement('label');
          label.innerHTML = this.children[0].value;
          //Canvas capture failed : if the input is empty on submit, the div is deleted
          if(this.children[0].value == ''){
            this.parentNode.parentNode.removeChild(this.parentNode);
            rect.stop();
            rect.stroke({width:0});
          }else{
            for (let j=0;j<miniatures.children.length;j++){
              //Should not replace itself
              console.log(j,miniatures.children.length);
              if (miniatures.children[j].children[1] === this && miniatures.children.length>j+1){
                continue;
              }
              //Replacing existing picture if labels match. Stops as soon as one is found
              if (miniatures.children[j].children[1].children[0].innerHTML == this.children[0].value){
                console.log('replace');
                miniatures.children[j].replaceChild(specialDiv.children[0],miniatures.children[j].children[0]);
                this.parentNode.parentNode.removeChild(this.parentNode);
                break;
              }
              //No match was found, a new character is created
              if (j==miniatures.children.length-1){
                this.replaceChild(label,this.children[0])
              }
            }
          }
        }
        canvas1.height = 100
        canvas1.width = 1.4 * canvas1.height;
        var canvastx1 = canvas1.getContext('2d');
        canvastx1.drawImage(videoElement,sourceX,sourceY,sourceWidth,sourceHeight,0,0,canvas1.width*0.95,canvas1.height*0.95);
      }



      setFunctions(){
        const draw = this.player.draw;
        const videoElement = this.player.video;
        const drawingBoard = this;
        this.rect=[];
        this.rect[0] = draw.polygon([0,0],[0,100],[100,100],[100,0]).fill('none').stroke({width:0, color:drawingBoard.colors[0]});
        this.rect[0].delay();
        var rect = this.rect;
        const layerState = this.layerState;

        this.$.addButton.addEventListener('click',()=>{this.addButton(this.rect[0])})
        this._popAnnos(layerState.annotations)

        layerState.addEventListener("populate_annotations",({detail:{data}}) => {
          this._popAnnos(data)
        });

        layerState.addEventListener("reset_annotations",() => {
          this.annotations=null;
        });

        layerState.addEventListener("add_annotation",({detail:{data}}) => {
          this.push("annotations",data);
          this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
        });
        layerState.addEventListener("update_annotation",({detail:{data}}) => {
          const annotationIndex=this.annotations.findIndex(annotation => annotation._id===data._id);
          this.splice("annotations", annotationIndex, 1,data);
          this.annotations.sort((a,b)=>a.fragment.currentTime-b.fragment.currentTime);
        });
        layerState.addEventListener("delete_annotation",({detail:{id}}) => {
          const annotationIndex=this.annotations.findIndex(annotation => annotation._id===id);
          this.splice("annotations", annotationIndex, 1);
        });


        this.player.on('doubletap',function(){
          if (videoElement.paused) {
            videoElement.play();
            for (let i = 0; i<rect.length;i++){
              rect[i].play();
            }
          }else {
            videoElement.pause();
            for (let i = 0; i<rect.length;i++){
              rect[i].pause();
            }
          }})

        }



        static get properties() {
          return {
            srcLogin: String,
            srcPlayer: String,
            srcLayerstate:String,
            id: String
          };
        }
      }
      customElements.define(CamomileDraw.is, CamomileDraw);
      </script>

    </dom-module>
